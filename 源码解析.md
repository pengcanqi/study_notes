# 消息存储

## 虚拟内存

### 虚拟内存产生的原因

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有**连续可用**的内存（一个完整的地址空间），但是实际上，它通常被分割成多个物理碎片，还有部分存储在外部磁盘管理器上，必要时进行数据交换。

通过借助虚拟内存，在内存不足时仍然可以运行程序。例如，在只剩 5MB 内存空间的情况下仍然可以运行 10MB 的程序。由于 CPU 只能执行加载到内存中的程序，因此，虚拟内存的空间就需要和内存中的空间**进行置换（swap）**，然后运行程序。

### 页表

系统必须得有办法判定某个虚拟页是否缓存在主存的某个地方。这具体可分为两种情况。

- 已经在主存中，就需要判断出该虚拟页存在于哪个物理页中。
- 不在主存中，那么系统必须判断虚拟页存放在磁盘的哪个位置，并且在物理主存中选择一个牺牲页，并将该虚拟页从磁盘复制到 主存，替换这个牺牲页。

这些功能由软硬件联合提供，包括操作系统，CPU中的**内存管理单元（Memory Management Unit,MMU）**和一个存放在物理内存中叫**页表（page table）**的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换成物理地址时都会读取页表。

![页表](C:\Users\80264302\Desktop\study_note_image\rocketmq\页表.png)

上图展示了一个页表的基本结构，页表就是一个**页表条目（Page Table Entry, PTE）**的数组。虚拟地址的每个页在页表中都有一个对应的PTE。在这里我们假设每个 PTE 是由一个有效位（Valid bit）和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 主存 中。

```
我们的cpu想访问虚拟地址所在的虚拟页(VP3)，根据页表，找出页表中第三条的值.判断有效位。
1. 如果有效位为1，DRMA缓存命中，根据物理页号，找到物理页当中的内容，返回。
2.若有效位为0，参数缺页异常，调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。
3.缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1。
4.将找到的内容映射到告诉缓存当中，CPU从告诉缓存中获取该值，结束。
```

### MMAP

![内存映射](C:\Users\80264302\Desktop\study_note_image\rocketmq\内存映射.png)

网上很多说MMAP是把磁盘文件映射到了虚拟内存上，对虚拟内存的修改就直接是对文件的修改。对这种说法不敢苟同。上图摘自《深入理解计算机系统》内存映射部分。我觉得MMAP这样理解可能好一些：

```
传统IO，进行读写时，需要把数据进行内核态和用户态的拷贝。
通过MMAP进行的IO，多个进程的不同虚拟内存映射到了同一块物理内存上，在用户态进行修改的同时，由于内核态和用户态虚拟内存映射到了同一块物理内存，所以不用进行内核态和用户态的数据拷贝。
```

1. 用户进程通过`write()`方法发起调用，上下文从用户态转为内核态
2. CPU将应用缓冲区中数据拷贝到socket缓冲区
3. DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，`write()`返回

### IO演进

**传统IO**

![传统IO](C:\Users\80264302\Desktop\study_note_image\rocketmq\传统IO.png)

**mmap**

![mmap](C:\Users\80264302\Desktop\study_note_image\rocketmq\mmap.png)

**sendfile**

![sendfile](C:\Users\80264302\Desktop\study_note_image\rocketmq\sendfile.png)

## 队列文件存储思考

**问题：MQ既然要接收大量的消息，这些消息如果全部存在内存，是否可行呢？**

在机器内存的限制下当然不行，那么就要考虑非内存的存储方式（**例如ActiveMQ是持久化到数据库中）**。

本地磁盘虽然慢（磁盘寻道），但是它的容量很大，可是如果我们顺序读写，会比随机读写性能强很多。

内存容量虽然小，但是它的速度很快。

所以，能不能有一种折中的方法，即用到内存又用到本地磁盘。

**填充和交换算法**，根据需要将固定大小（例如128M）的页面文件映射到内存中，并在固定的生存时间（TTL）时间内未访问该文件时取消映射。 通过这种设计，我不仅可以更安全，更有效地使用内存，而且可以在需要时删除一些用过的页面文件以节省磁盘空间。

**队列是一种前置读、后置追加的结构，那么只需要将队列的前部分和后部分放入内存，中间部分在磁盘操作，就能保证高效、大容量操作。**

读取和追加操作总是可以发生在内存中，这意味着入队和出队操作总是接近O(1)访问速度。

但如果想要查询在磁盘上的消息，速度还是会降下来，为此，我们可以再维护一份索引，记录目标消息在磁盘文件上的偏移量，以随机读接口去访问。

至此，一个很实用的队列文件存储系统就有眉目了。

## RocketMq的存储设计

## MappedFile

### transientStorePool

```java
public class TransientStorePool {
    private final int poolSize; //池子大小
    private final int fileSize; // 缓冲池每个缓存的大小
    private final Deque<ByteBuffer> availableBuffers;
    private final MessageStoreConfig storeConfig;
    /**
     * It's a heavy init method.
     */
    public void init() {
        for (int i = 0; i < poolSize; i++) {
            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);

            final long address = ((DirectBuffer) byteBuffer).address();
            Pointer pointer = new Pointer(address);
            /**
             *系统调用 mlock允许程序在物理内存上锁住它的部分或全部地址空间。这将阻止Linux 将这个内存页调度到			 				*交换空间swapspace），即使该程序已有一段时间没有访问这段空间,提高存储性能
             */
            LibC.INSTANCE.mlock(pointer, new NativeLong(fileSize));

            availableBuffers.offer(byteBuffer);
        }
    }
}
```

<img src="C:\Users\pengc\Desktop\study\study_note_image\rocketmq\transientStorePool.PNG" alt="transientStorePool" style="zoom: 67%;" />

### 刷盘策略

**同步刷盘**

```
GroupCommitService：同步刷盘策略
```

**异步刷盘**

```
FlushRealTimeService：采用mmap的异步刷盘策略
CommitRealTimeService：采用TransientStorePool+filechannel实现读写分离架构的异步刷盘策略
```

**刷盘线程唤醒策略**

在asyncPutMessages异步追加消息时（不代表仅仅是异步发送，producer同步发送也会调用此方法）：

```
CompletableFuture<PutMessageStatus> flushOKFuture = submitFlushRequest(result, messageExtBatch);
```

在putMessage同步追加消息时：

```
handleDiskFlush(result, putMessageResult, msg)
```

**同步刷盘的具体实现**

```java
class GroupCommitService extends FlushCommitLogService {
    private volatile List<GroupCommitRequest> requestsWrite = new ArrayList<GroupCommitRequest>();
    private volatile List<GroupCommitRequest> requestsRead = new ArrayList<GroupCommitRequest>();

    public synchronized void putRequest(final GroupCommitRequest request) {
        synchronized (this.requestsWrite) {
            this.requestsWrite.add(request);
        }
        this.wakeup();
    }

    private void swapRequests() {
        List<GroupCommitRequest> tmp = this.requestsWrite;
        this.requestsWrite = this.requestsRead;
        this.requestsRead = tmp;
    }
}
```

所谓的同步刷盘，就是在每次向commitLog对于mappedFile追加完消息后，通过GroupCommitService的putRequest，向requestWrite列表增加一个刷盘请求，然后就返回了。然后GroupCommitService内部的run方法，每次执行时，调用swapRequests方法，把当前累计到的刷盘请求，移动到requestsRead列表中，再逐个消费requestsRead列表中的刷盘请求。

概括来说：**同步刷盘，其实就是每次commitlog追加消息，都会往一个刷盘请求列表里扔一个刷盘请求，而后台有一个线程是在异步消费这个刷盘请求列表**

最后再来个QA环节

```
Q:为什么要这样设计同步刷盘

A:因为刷盘是IO操作很耗时间，如果producer真的要发送完一条消息，且等到消息落盘的话，就会有很多的producer阻塞。
```

**异步刷盘的具体实现**

和同步刷盘每次有消息来就往列表里仍消息不同，每次有消息追加，都会尝试唤醒异步刷盘线程（如果它处于阻塞状态）。

然后异步刷盘线程，会根据以下条件决定是刷盘亦或者继续阻塞：

```
1.脏页数是否达到阈值

2.刷盘间隔时间是否达到阈值
```

## Remoting网络通信层

### 核心类简介

![网络层类图](C:\Users\pengc\Desktop\study\study_note_image\rocketmq\网络层类图.png)

RocketMQ的网络层基于netty实现，类图如上。

NettyRomotingClient用于：producer、consumer、broker。

NettyRomotingServer用于：broker、nameServer。

我们可以看到NettyRomotingClient多了个nameServerAddressList，因为作为客户端，需要定时去主动与nameServer进行通信，获取最新的路由信息。

### NettyDecoder

```java
public class NettyDecoder extends LengthFieldBasedFrameDecoder {
    private static final InternalLogger log = InternalLoggerFactory.getLogger(RemotingHelper.ROCKETMQ_REMOTING);

    private static final int FRAME_MAX_LENGTH =
        Integer.parseInt(System.getProperty("com.rocketmq.remoting.frameMaxLength", "16777216"));

    public NettyDecoder() {
        super(FRAME_MAX_LENGTH, 0, 4, 0, 4);
    }

    @Override
    public Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        ByteBuf frame = null;
        try {
            frame = (ByteBuf) super.decode(ctx, in);
            if (null == frame) {
                return null;
            }

            ByteBuffer byteBuffer = frame.nioBuffer();

            return RemotingCommand.decode(byteBuffer);
        } catch (Exception e) {
            log.error("decode exception, " + RemotingHelper.parseChannelRemoteAddr(ctx.channel()), e);
            RemotingUtil.closeChannel(ctx.channel());
        } finally {
            if (null != frame) {
                frame.release();
            }
        }

        return null;
    }
}
```

NettyDecoder是NettyRomotingClient/NettyRomotingServer的入站解码器。把入站事件解析成RemotingCommand。而我们知道rocketmq的消息是不定长的，所以理所当然能知道RemotingCommand也是不定长的，所以我们的入站解码器是继承自LengthFieldBasedFrameDecoder，长度域解码器。

### NettyServerHandler

```java
public void processMessageReceived(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {
    final RemotingCommand cmd = msg;
    if (cmd != null) {

        switch (cmd.getType()) {
            case REQUEST_COMMAND:
                // 客户端发起的请求 走这里
                processRequestCommand(ctx, cmd);
                break;
            case RESPONSE_COMMAND:
                // 客户端响应给服务器的 数据 走这里
                processResponseCommand(ctx, cmd);
                break;
            default:
                break;
        }
    }
}

public enum RemotingCommandType {
    // 请求命令
    REQUEST_COMMAND,
    // 回复命令
    RESPONSE_COMMAND;
}
```

nettyServerHandler是NettyRomotingClient/NettyRomotingServer中的一个inbound事件处理器，处理入站请求。入站请求，经过NettyDecoder解码后，解析成RemotingCommand。RemotingCommand又分为请求命令和回复命令两种类型，并根据两种命令进行不同的逻辑处理。

### 请求命令与回复命令

```
请求命令：客户端向服务端请求，不需要知晓响应结果，这个时候服务端接收到的命令为请求命令。

回复命令：客户端c1向服务端s2请求，需要知晓服务端s2的响应结果，服务端s2处理完命令请求，拿到响应结果，又作为客户端c2，向C1发送响应结果，这个时候c1作为S1，接受到的请求就是响应请求。
```

典型的交互如下所示：

![请求命令和回复命令](C:\Users\pengc\Desktop\study\study_note_image\rocketmq\请求命令和回复命令.png)

请求命令处理流程：

- 根据命令号，在处理器表中找到处理器
- 处理器处理事件
- 执行处理回调，写回响应（可选项）

回复命令处理流程：

- 根据回复命令的的opaque，在responseTable找到对应的responseFuture
- 将RemotingCommand中的reponse设置到responseFuture中
- 唤醒正在等待的responseFuture响应的线程
- 执行回调，处理response数据

### scanResponseTable

```java
public void scanResponseTable() {
    final List<ResponseFuture> rfList = new LinkedList<ResponseFuture>();
    Iterator<Entry<Integer, ResponseFuture>> it = this.responseTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<Integer, ResponseFuture> next = it.next();
        ResponseFuture rep = next.getValue();

        if ((rep.getBeginTimestamp() + rep.getTimeoutMillis() + 1000) <= System.currentTimeMillis()) {
            rep.release();
            it.remove();
            rfList.add(rep);
            log.warn("remove timeout request, " + rep);
        }
    }

    for (ResponseFuture rf : rfList) {
        try {
            executeInvokeCallback(rf);
        } catch (Throwable e) {
            log.warn("scanResponseTable, operationComplete Exception", e);
        }
    }
}
```

scanResponseTable是NettyRomotingClient/NettyRomotingServer的核心定时任务之一，随着NettyRomotingClient/NettyRomotingServer启动而启动，每1s执行一次。扫描 responseTable 表，将过期的 responseFuture 移除。

NettyRomotingClient中的responseTable：拉取消息，发送同步消息，获取路由信息等操作。

NettyRomotingServer中的responseTable：broker主动向客户端服务端通知等操作。（其实broker里面也有NettyRomotingClient啊，感觉也可以用NettyRomotingClient实现）

### 同步调用与回执

![同步调用](C:\Users\pengc\Desktop\study\study_note_image\rocketmq\同步调用.png)

### 异步调用与回执

![异步请求](C:\Users\pengc\Desktop\study\study_note_image\rocketmq\异步请求.png)

### 单向与回执

单向调用与异步调用类似，发送消息就立即调用返回了。但是与异步调用不同的是，单向调用并不关心处理结果，而只关心是否发送结果。

## NameServer

NameServer主要包括两个功能：**Broker管理**，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；**路由信息管理**，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。

### RouteInfoManager

Broker管理/路由信息管理功能都通过RouteInfoManager来处理，RouteInfoManager维护了理由信息和broker存活信息的map。

```java
public class RouteInfoManager {
    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);
    private final static long BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final HashMap<String/* topic */, List<QueueData>> topicQueueTable;
    private final HashMap<String/* brokerName */, BrokerData> brokerAddrTable;
    private final HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable;
    private final HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable;
    private final HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable;
}
```

### Broker管理

#### 核心类介绍

```java
class BrokerLiveInfo {
    private long lastUpdateTimestamp; //上一次心跳更新时间
    private DataVersion dataVersion; // broker版本信息
    private Channel channel;
    private String haServerAddr;
}

public class DataVersion extends RemotingSerializable {
    private long timestamp = System.currentTimeMillis();
    private AtomicLong counter = new AtomicLong(0);// 自增版本序列号

    public void assignNewOne(final DataVersion dataVersion) {
        this.timestamp = dataVersion.timestamp;
        this.counter.set(dataVersion.counter.get());
    }

    //当broker信息有变化时，会调用nextVersion方法
    public void nextVersion() {
        this.timestamp = System.currentTimeMillis();
        this.counter.incrementAndGet();
    }
}
```

#### scanNotActiveBroker

```java
    public void scanNotActiveBroker() {
        Iterator<Entry<String, BrokerLiveInfo>> it = this.brokerLiveTable.entrySet().iterator();
        while (it.hasNext()) {
            Entry<String, BrokerLiveInfo> next = it.next();
            long last = next.getValue().getLastUpdateTimestamp();
            if ((last + BROKER_CHANNEL_EXPIRED_TIME) < System.currentTimeMillis()) {
                RemotingUtil.closeChannel(next.getValue().getChannel());
                it.remove();
                log.warn("The broker channel expired, {} {}ms", next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);
                // 参数1：brokerAddr
                // 参数2：服务器与broker物理节点的 ch
                this.onChannelDestroy(next.getKey(), next.getValue().getChannel());
            }
        }
    }
```

随着nameServer启动而启动的定时任务,每10s检测一次broker存活信息，如果上次心跳更新时间距离现在大于2分钟则broker下线。

而brokerLiveTable的更新是在broker启动的时候，会启动一个定时任务，执行registerBrokerAll（）方法，如果判断DataVersion没有改变，就更新心跳时间。

### 路由信息管理

![元数据](C:\Users\pengc\Desktop\study\study_note_image\rocketmq\元数据.png)

路由信息由RouteInfoManager在的topicQueueTable和brokerAddrTable来维护。总体来说就是一个topic对应多个QueueData，每个QueueData对应一个broker主从机器集合。而客户端从NameServer中获取到的路由信息如下所示：


```
public class TopicRouteData extends RemotingSerializable {
    private String orderTopicConf;
    private List<QueueData> queueDatas;
    private List<BrokerData> brokerDatas;
    private HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable;
}
```

### 读写锁在NameServer的使用

可能会存在同时需要取路由信息和修改理由信息的情况。在NameServer中，通过lock字段，即通过读写锁，解决并发读写路由信息的问题。

## Producer消息生产者

### 自动创建主题

#### 消费者向不存在主题发送消息

![自动创建主题](C:\Users\pengc\Desktop\study\study_note_image\rocketmq\自动创建主题.png)

自动创建主题流程如上图所示。

当producer尝试向一个不存在的topic发送消息时，发送程序会报错：**No route info of this topic**。但是broker有个配置项**autoCreateTopicEnable**，当开启时，producer可以向一个不存在的topic发送消息，broker在收到消息后会自动创建主题。如上图所示，当autoCreateTopicEnable关闭时，无论从哪里都获取不到test/TWB102这个主题的路由信息，就会抛出No route info of this topic的异常。

#### 为什么生产上不建议自动创建主题

为了消息发送的高可用，希望新创建的Topic在集群中的每台Broker上创建对应的队列，避免Broker的单节点故障。而自动创建主题，得是broker收到了这个不存在的主题的消息，才会自动创建。那另一个broker要是没收到，那相当于这个topic就不会在这个broker上创建。

家陆的疑问：那他妈的他为啥不收到了一个topic创建请求做一下同步？

我个人的见解：同步这个得nameserver来做了，但是nameserver的设计又是轻量级的，是ap的，由它来做这个操作不符合设计初衷。

### 消息重投

#### 同步消息重投

![同步消息重投](C:\Users\pengc\Desktop\study\study_note_image\rocketmq\同步消息重投.png)

```java
private int retryTimesWhenSendFailed = 2;
private boolean retryAnotherBrokerWhenNotStoreOK = false;
```

同步消息重投由上述两个变量控制，重投逻辑如上图所示，简单来说就是for循环里发送消息，for循环的循环次数就是最大重试次数，发送失败了就重试，发送成功了就返回发送结果。

同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed +  1次。**不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢**。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。

#### 异步消息重投

![异步消息重投](C:\Users\pengc\Desktop\study\study_note_image\rocketmq\异步消息重投.png)

retryTimesWhenSendAsyncFailed:异步发送失败重试次数，**异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢**。

