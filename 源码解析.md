# 消息存储

## 虚拟内存

### 虚拟内存产生的原因

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有**连续可用**的内存（一个完整的地址空间），但是实际上，它通常被分割成多个物理碎片，还有部分存储在外部磁盘管理器上，必要时进行数据交换。

通过借助虚拟内存，在内存不足时仍然可以运行程序。例如，在只剩 5MB 内存空间的情况下仍然可以运行 10MB 的程序。由于 CPU 只能执行加载到内存中的程序，因此，虚拟内存的空间就需要和内存中的空间**进行置换（swap）**，然后运行程序。

### 页表

系统必须得有办法判定某个虚拟页是否缓存在主存的某个地方。这具体可分为两种情况。

- 已经在主存中，就需要判断出该虚拟页存在于哪个物理页中。
- 不在主存中，那么系统必须判断虚拟页存放在磁盘的哪个位置，并且在物理主存中选择一个牺牲页，并将该虚拟页从磁盘复制到 主存，替换这个牺牲页。

这些功能由软硬件联合提供，包括操作系统，CPU中的**内存管理单元（Memory Management Unit,MMU）**和一个存放在物理内存中叫**页表（page table）**的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换成物理地址时都会读取页表。

![页表](C:\Users\80264302\Desktop\study_note_image\rocketmq\页表.png)

上图展示了一个页表的基本结构，页表就是一个**页表条目（Page Table Entry, PTE）**的数组。虚拟地址的每个页在页表中都有一个对应的PTE。在这里我们假设每个 PTE 是由一个有效位（Valid bit）和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 主存 中。

```
我们的cpu想访问虚拟地址所在的虚拟页(VP3)，根据页表，找出页表中第三条的值.判断有效位。
1. 如果有效位为1，DRMA缓存命中，根据物理页号，找到物理页当中的内容，返回。
2.若有效位为0，参数缺页异常，调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。
3.缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1。
4.将找到的内容映射到告诉缓存当中，CPU从告诉缓存中获取该值，结束。
```

### MMAP

![内存映射](C:\Users\80264302\Desktop\study_note_image\rocketmq\内存映射.png)

网上很多说MMAP是把磁盘文件映射到了虚拟内存上，对虚拟内存的修改就直接是对文件的修改。对这种说法不敢苟同。上图摘自《深入理解计算机系统》内存映射部分。我觉得MMAP这样理解可能好一些：

```
传统IO，进行读写时，需要把数据进行内核态和用户态的拷贝。
通过MMAP进行的IO，多个进程的不同虚拟内存映射到了同一块物理内存上，在用户态进行修改的同时，由于内核态和用户态虚拟内存映射到了同一块物理内存，所以不用进行内核态和用户态的数据拷贝。
```

1. 用户进程通过`write()`方法发起调用，上下文从用户态转为内核态
2. CPU将应用缓冲区中数据拷贝到socket缓冲区
3. DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，`write()`返回

### IO演进

**传统IO**

![传统IO](C:\Users\80264302\Desktop\study_note_image\rocketmq\传统IO.png)

**mmap**

![mmap](C:\Users\80264302\Desktop\study_note_image\rocketmq\mmap.png)

**sendfile**

![sendfile](C:\Users\80264302\Desktop\study_note_image\rocketmq\sendfile.png)

## 队列文件存储思考

**问题：MQ既然要接收大量的消息，这些消息如果全部存在内存，是否可行呢？**

在机器内存的限制下当然不行，那么就要考虑非内存的存储方式（**例如ActiveMQ是持久化到数据库中）**。

本地磁盘虽然慢（磁盘寻道），但是它的容量很大，可是如果我们顺序读写，会比随机读写性能强很多。

内存容量虽然小，但是它的速度很快。

所以，能不能有一种折中的方法，即用到内存又用到本地磁盘。

**填充和交换算法**，根据需要将固定大小（例如128M）的页面文件映射到内存中，并在固定的生存时间（TTL）时间内未访问该文件时取消映射。 通过这种设计，我不仅可以更安全，更有效地使用内存，而且可以在需要时删除一些用过的页面文件以节省磁盘空间。

**队列是一种前置读、后置追加的结构，那么只需要将队列的前部分和后部分放入内存，中间部分在磁盘操作，就能保证高效、大容量操作。**

读取和追加操作总是可以发生在内存中，这意味着入队和出队操作总是接近O(1)访问速度。

但如果想要查询在磁盘上的消息，速度还是会降下来，为此，我们可以再维护一份索引，记录目标消息在磁盘文件上的偏移量，以随机读接口去访问。

至此，一个很实用的队列文件存储系统就有眉目了。

## RocketMq的存储设计

## MappedFile